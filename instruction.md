# 声明

使用的matlab程序版本为r2024b，应使用最新的函数/语法/用例

# 普遍问题

## 属性定义太扁平，混乱

- 不同属性的用途与特点不同，应使用不同关键字在单独的区块中初始化

- 缺少属性验证

- 应按需编写不同的初始化方法，应用于类内部计算并更新属性值的方法应放在private块内

## 改正示例

对所有非只读非依赖的属性在属性块内根据各自的用途添加维度，类型验证与默认值。维度规定仅需要在属性值为非标量时显式指定，默认值应该是必须的，而不是在main函数中硬编码，类型验证应至少指定大类。

Population类中定义的大部分属性都属于一经初始化后就不会变更的类型，但与此同时，这些属性又需要默认值与参数赋值两种初始化方法，应将这些参数独立为一个单独的PopulationParams类，在该类中的非只读属性块内初始化种群参数，设置默认值与类型验证，将该句柄对象赋值给polulation类的常量属性。并根据种群参数计算依赖参数（比如通过一个性别参数计算另一个），可将需要非简单计算的依赖参数写入dependent类别的属性块中，减少内存占用，比如繁殖概率，死亡概率。计算也应移入该新类中对应属性的get方法中，由于这些方法并无公开需求，方法块应为private类型。

PopulationParams计划为抽象基类UIPropertyControlBaseClass的实现，通过弹窗确认是否修改默认值，至此参数初始化部分完成。这部分的实现还未完成，因而类定义处暂时为handle而不是该抽象基类，后续补充，此次编码无需阅读未完成的抽象基类。

# 针对性问题

## Individual.m

lifespan除对象的life_status变为‘death’，否则应始终为空或0，gender应使用分类数组，将值1，0映射为字符串male，female，这样更有可读性。我注意到life_status并没有被设置为分类数组，你似乎没有按我的要求编写代码，包括后续的update方法中，你使用了strcmp判断生命状态，这对分类数组是完全没有必要的。所有分类数组类型都应是protected，以防意外的新类别。life_status应被显式指定为有序（ordinal）。

由于基本上不需要对个体属性直接初始化，而是通过Population类的方法批量赋值，因而构造函数是不必要的。

update方法中，更新生命状态的逻辑应使用switch case，判断对象为年龄，case中设置life_status。死亡判定的前提是life_status为old，其它条件是多余的，由于死亡概率数组的最后一位经过归一化后是1，79行的elseif也是没有必要的。alive参数由于Population类中直接访问life_status，因而也是不必要的输出。

can_reproduce与life_status定位重合，直接删除。

## Population.m

98行开始的initializePopulation方法，避免循环的方法应使用较新的createArray，如果你的知识库没有对应知识，可参考以下用例：

```matlab
当指定一个标量时， createArray 返回一个方阵。使用标量作为输入创建一个 3x3 的零矩阵。
A = createArray(3)
A = 3×3

     0     0     0
     0     0     0
     0     0     0

您可以单独指定维度。通过指定两个维度创建一个 2x3 的零矩阵。
B = createArray(2,3)
B = 2×3

     0     0     0
     0     0     0

classname 参量
使用 classname 参量指定数组的类：
X = createArray(dims,"classname")

创建一个 SimpleValue 类的 1×5 数组。MATLAB 不带参量调用构造函数一次，并用该实例的副本填充数组。
X = createArray(1,5,"SimpleValue")


Like 参量
使用 Like 名称-值参量以现有实例或数组为原型创建对象数组：
X = createArray(dims,Like=prototype)

创建 SimpleValue 的实例 phi，并将 1.618 赋给 prop1。使用 Like 和 phi 创建该类的 2×2 对象数组。返回的数组 L 具有与 phi 相同的类。
phi = SimpleValue(1.618);
L = createArray(2,2,Like=phi)


FillValue 参量
要创建包含非默认对象的数组，请使用构造函数的输入参量创建一个实例，然后将其用作 createArray 的填充值：
X = createArray(dims,FillValue=instance)

创建一个 SimpleValue 的实例，将 7 赋给 prop1，并使用该实例和 FillValue 名称-值参量创建一个 3×1 数组。
s = SimpleValue(7);
F = createArray(3,1,FillValue=s)
```

使用该函数创建完整大小的对象句柄数组后，再使用对句柄的set，get函数或数组索引+圆点表示法对对象句柄数组的指定属性批量赋值即可，参考该例子：`Values = [A.Value];arrayCells = {A.array};`   。

形如这样的写法能有效捕获对象数组中所有属性值，将其赋值给一维数组，元素的索引对应原始对象数组的索引，即使对象数组不是一维也是如此；而花括号写法可处理属性值为非标量的情形。

127行开始的simulateYear方法，应使用arrayfun来避免for循环，处理对象限定为年龄状态不为“death”的个体，使用逻辑索引即可实现。update执行完毕后，类似上述写法获取个体的年龄状态数组，筛选其中年龄状态为mature的。接下来152行开始到方法结尾的繁殖逻辑需要全部重构，根据年龄状态数组中成熟性别数量少的一方，通过对应年龄的繁殖概率选出确定繁殖的个体数组，通过nchoosek选择另一方参与配对的个体数组，通过性别属性获取双方的性别，这样就避免了if分支逻辑的同时，将性别失衡作为了繁殖约束。这样就得到了子代的亲本双方的唯一编号数组。生成寿命需要删除，因为寿命通过死亡概率在每次更新中决定，因而这是不必要的。预分配新个体数组也应使用createArray函数。创建新个体不应使用循环，涉及批量赋值对象数组中对象属性的，使用以下写法：

```matlab
[A.val] = deal(scalar);
veccell = num2cell(vector);
[A.val] = deal(veccell{:});
```

对于亲代信息，由于溯源会生成二叉树结构，因此只存储当前亲代，在使用以上写法分发输入时，设定num2cell的dim属性来将拆分单元指定为二元组，而非将每个元素都拆分出来。全部属性初始化完毕后，将next_id整体加上新个体数量即可。最后串联新个体数组到当前个体数组。

关于个体id，在next_id之外还应维护一个世代之间独立的起始id，这应该是一个等同于当前最多代数的列向量，而非一个标量值，区分于世代间共用的个体编号。因此，亲代编号也应另外维护一组。方法同上。

248行开始的getAliveIndividuals方法缺乏一般性与结构性。仅应排除未出生个体，已死亡个体也是当前种群的一部分。应简单改名称为getstats，统计信息分群体信息与个体信息大类，群体信息为标量或能表达群体特征的数组；个体信息为与对象数组同等大小的数组。多数统计信息可能是不必要的，因为绘图函数会自动计算统计值，且更全面。

### main.m

main函数暂无修改计划，待类结构稳定后继续编写。
